<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>垃圾回收</title>
	<script>
		/*
		 引用
		 垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。
		 例如，一个 JavaScript 对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）
		 在这里，"对象"的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）

		 引用计数垃圾收集
		 这是最简单的垃圾收集算法。此算法把"对象是否不再需要"简化定义为"对象有没有其他对象引用到它"。
		 如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。
		 */
		var o = {
			a: {
				b: 2
			}
		};
		// 两个对象被创建，一个做为另一个的属性被引用，另一个被分配给变量 o
		// 很显然，没有一个可以被垃圾收集
		var o2 = o; // o2变量是第二个对"这个对象"的引用，现在，"这个对象"的原始引用 o 被 o2 替换了
		o = 1;
		var oa = o2.a; // 引用"这个对象"的 a 属性
		// 现在，"这个对象"有两个引用了，一个是 o2，一个是 oa
		o2 = "yo"; // 最初的对象现在已经是零引用了
		// 他可以被垃圾回收了
		// 然而它的属性 a 的对象还在被 oa 引用，所以还不能回收
		oa = null; // a 属性的那个对象现在也是零引用了，它可以被垃圾回收了

		/*
		 限制：循环引用会
		 这个简单的算法有一个限制，就是如果一个对象引用另一个（形成了循环引用），他们可能"不再需要了"，但是他们不被回收。
		 */
		// 两个对象被创建，并互相引用，形成了一个循环
		// 他们被调用之后不会离开函数作用域
		// 所以他们已经没有用了，可以被回收了
		// 然而，引用计数算法考虑到他们互相都有至少一次引用，所以他们不会被回收
		function f() {
			var o = {};
			var o2 = {};
			o.a = o2; // o 引用 o2
			o2.a = o; // o2 引用 o
			return "azerty";
		}
		f();
		/*
		 实际当中的例子
		 IE 6、7 对 DOM 对象进行引用计数回收。对他们来说，一个常见问题就是内存泄露：
		 */
		var div = document.createElement("div");
		div.onclick = function () {
			// doSomething();
		};
		// div有了一个引用指向事件处理属性 onclick
		// 事件处理也有一个对div的引用可以在函数作用域中被访问到
		// 这个循环引用会导致两个对象都不会被垃圾回收

		/*
		 标记-清除算法
		 这个算法把"对象是否不再需要"简化定义为"对象是否可以获得"

		 这个算法假定设置一个叫做根的对象（在 JavaScript 里，根是全局对象）。定期的，垃圾回收器将从根开始，找所有从根开始引用的对象
		 然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。

		 这个算法比前一个要好，因为"有零引用的对象"总是不可获得的，但是相反却不一定，参考"循环引用"

		 从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对 JavaScript 垃圾回收算法的改进都是基于标记-清除算法的改进
		 并没有改进标记-清除算法本身和它对"对象是否不再需要"的简化定义。循环引用不再是问题了

		 在上面的示例中，函数调用返回之后，两个对象从全局对象出发无法获取。因此，他们将会被垃圾回收器回收。

		 第二个示例同样，一旦 div 和其事件处理无法从根获取到，他们将会被垃圾回收器回收。

		 限制: 对象需要明确的不可获得尽管这是一个限制，但是很少会被突破，这也就是为什么在现实中很少人会去关心垃圾回收机制。
		 */
	</script>
</head>
<body>

</body>
</html>