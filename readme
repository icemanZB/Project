秒 转 分

var s=1234;

alert(parseInt(s/60)+'分'+s%60+'秒');



全局变量 是window上面的属性

var a=12;
window.alert(window.a);  //window 可以省略


// 没有定义的变量 --- 报错

// 没有定义的属性 ---  undefined

变量不属于任何人  属性属于一个对象  其实 变量=属性

任何对象都能加属性

var arr=[1,2,3,4];

arr.a=12;
alert(arr.a);

arr.aaa=function ()
{
alert('abc');
};

arr.aaa();
同理 函数 是自由的 方法是属于某个对象

但不能在系统的对象中随意的添加属性方法 否则会覆盖原来的内容


var str='abcdef';

alert(str.search('de')); // 3  de在原字符串中从第三个开始

// 找到并且返回字符串出现的位置，没找到为-1

// 获取字符串第一个
var str='12345';   等于讲把字符串看成数组了

alert(str[0]);  不兼容IE7


//  charAt()  全兼容
alert(str.charAt(0)); //获取字符串某一位的值


var arr=[1,2,3,5,6,7];

arr.length=3;

alert(arr); // 1,2,3

arr.push(8);  //数组添加 在末尾

arr.pop();  // 删除数组的尾部
arr.shift();  //头部删除元素
arr.unshift(); // 添加头部元素

清空数组 arr.length=0;

//删除元素
arr.splice(2，3);  // 起点(下标)，长度(个数)

arr.splice(2,0,'a','b','c');  //插入元素 (起点,长度,元素...)

//数组链接

var a=[1,2,3]; var b=[4,5,6];

alert(a.concat(b));

var arr=[1,2,3,4];

alert(arr.join('-'));  // 1-2-3-4


//数组排序  (字符串)

var arr=['float','width','alpha','zoom','left'];

arr.sort();

alert(arr);


//排数字

var arr=[12,8,99,19,112];


arr.sort(function (n1,n2){
	return n1-n2;
});

26、JavaScript在IE浏览器和Firefox浏览器中的差异总结

    (1) HTML对象的 id 作为对象名的问题

        IE: HTML 对象的 ID 可以作为 document 的下属对象变量名直接使用
        Firefox: 不支持
    解决方法: 使用document.getElementById 替代 document.all

    (2) 如果控件只有name,没有id, 用 getElementById 时:

        IE: 可以找到对象
        Firefox: 返回NULL
    解决方法: 所有控件必须设置ID属性

    (3) Eval:

        IE: 支持,利用 eval(idName) 可以取得 id 为 idName 的 HTML 对象
        Firefox: 不支持
    解决方法: 统一使用 getElementById(idName) 代替 eval(idName)

    (4) Event:

        IE: 用全局对象window.event
        Firefox: event只能在事件发生的现场使用,在调用函数时传入event对象 function(ev){}
    解决方法: 使用之前做一下浏览器类型判断,各用各的。

    (5) 对象名称中美元符号'$' 改为使用下划线'_'

    (6) 集合类对象问题

        IE: 可以使用()或[]获取集合类对象
        Firefox: 只能使用[]获取集合类对象

    解决方法: 统一使用[]获取集合类对象。
        例: document.form.item("itemName") 这样的语句改为 document.form.elements["elementName"]

    (7) 变量名与某 HTML 对象 id 相同的问题

        IE: 不能使用与 HTML 对象 id 相同的变量名
        Firefox: 可以使用
    解决方法: 在声明变量时,一律加上 var 以避免歧义,这样在 IE 中亦可正常运行。
            此外,最好不要取与 HTML 对象 id 相同的变量名,以减少错误。

    (8) Event定位问题

        IE: 支持 event.x 和 event.y
        Firefox: 支持 event.pageX 和 event.pageY
    解决方法: 统一使用 event.clientX 和 event.clientY
            但是在Firefox中 event.clientX 与 event.pageX 有微妙的差别(当整个页面有滚动条的时候)
            不过大多数时候是等效的。如果要完全一样,可以判断浏览器类型后对应使用。

    (9) 父结点的问题

        IE: parentElement parentElement.children
        Firefox: parentNode parentNode.childNodes
        childNodes的下标的含义在IE和Firefox中不同,Firefox使用DOM规范,childNodes中会插入空白文本节点。
        一般可以通过node.getElementsByTagName()来回避这个问题。
        当html中节点缺失时,IE和Firefox对parentNode的解释不同。例如:

    <form>
        <table>
            <input/>
        </table>
    </form>
    IE: input.parentNode的值为空节点
    Firefox: input.parentNode的值为form
    解决方法: Firefox中节点没有removeNode方法,必须使用如下方法 node.parentNode.removeChild(node)

    (10) const 问题

        IE: 不支持 const 关键字。如 const constVar = 32; 在IE中这是语法错误
        Firefox: 支持
    解决方法: 不使用 const 以 var 代替

    (11) body 对象

        IE: 在body标签完全被读入之后才存在
        Firefox: 在body标签没有被浏览器完全读入之前就存在

    (12) 自定义属性问题

        IE: 可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性
        Firefox: 只能使用getAttribute()获取自定义属性
    解决方法: 统一通过getAttribute()获取自定义属性

    (13) event.srcElement问题

        IE: even.srcElement
        Firefox: even.target
    解决方法: 使用时判断浏览器类型,各用各的

    (14) 模态和非模态窗口

        IE: 支持模态和非模态窗口
        Firefox: 不支持
    解决方法: 直接使用window.open(pageURL,name,parameters)方式打开新窗口。
            如果需要将子窗口中的参数传递回父窗口,可以在子窗口中使用window.opener来访问父窗口。

    (15) innerText

        IE: innerText
        Firefox: textContent

    (16) 类似 obj.style.height = imgObj.height 的语句

        IE: 有效
        Firefox: 无效
        解决方法: 统一使用obj.style.height = imgObj.height + 'px';
jquery prop 方法解析 http://blog.csdn.net/chaiyining007/article/details/8218038

jQuery中跳出 each 循环  continue 可以使用 return true
                        break    可以使用 return false

var _href = _menu.getAttribute('href');  // 获取到 #item1
var _href=_menu.href; // 获取到的是浏览器的路径
<a href="#item1" class="current">1F 男装</a>

使用正则表达式来判断一个字符串中是否有某个字符串
if (/active/.test(aLi[i].className)) {}

javascript中top、clientTop、scrollTop、offsetTop的讲解
http://www.cnblogs.com/trlanfeng/archive/2012/11/04/2753280.html

js中 offsetHeight 是动态获取值
http://www.kuqin.com/shuoit/20140113/337572.html

jQuery之位置
http://www.cnblogs.com/kissdodog/archive/2012/12/09/2809770.html
oUl.position().top ==> oUl.get(0).offsetTop

$("#content").find(".item") == $('#content .item')  但是后者效率低

var arr=[1,2,3];
pop() 方法用于删除并返回数组的最后一个元素
unshift() 方法可向数组的开头添加一个或更多元素,并返回新的长度

arr.unshift(arr.pop());  // 3   arr => [3, 1, 2]

var arr=[1,2,3];
shift() 方法用于把数组的第一个元素从其中删除,并返回第一个元素的值
push()  方法可向数组的末尾添加一个或多个元素,并返回新的长度

arr.push(arr.shift()); // 3   arr => [2, 3, 1]

Math.random()  random() 方法可返回介于 0 ~ 1 之间的一个随机数


appendChild于insertBefore http://www.cnblogs.com/ATree/archive/2011/09/26/JS-appendChild-insertBefore.html

复制节点 cloneNode() 如果参数是 true 就是一起复制里面的子节点, false 就只复制当前节点 不会复制里面的子节点
返回的节点不属于文档树,它的 parentNode 属性为 null
当复制的是 Element 节点时,它的所有属性都将被复制,但要注意,当前节点上注册的事件监听器函数不会被复制

jquery clone() 无参数的情况是潜复制(不复制事件)  clone(true) 深复制(复制事件)

jquery stop() 方法停止当前正在运行的动画
工作中遇到过的实际案例:
在项目里做的一个下拉菜单,当鼠标移上去的时候就菜单显示,当鼠标离开的时候菜单隐藏

如果我快速不断地将鼠标移入移出菜单(即当菜单下拉动画未完成时,鼠标又移出了菜单)就会产生"动画积累"
当鼠标停止移动后,积累的动画还会持续执行,直到动画序列执行完毕

解决方法:在写动画效果的代码前加入 stop(true,true) 这样每次快速的移入移出菜单就正常了
当移入一个菜单的时候,停止所有加入队列的动画,但是完成当前的动画(跳至当前动画的最终效果位置)

Math.pow(x,y) x 的 y 次幂

$(window).width()  获取窗口的宽度

容器页面居中 ($(window).width()-$('#obj').outWidth())/2 、 ($(window).height()-$('#obj').outHeight())/2

触发滚动条事件和resize

$(window).on('resize scroll',function(){
    $('div').css('top',($(window).height()-$('#obj').outHeight())/2 + $(window).scroll());
})

js里用 "parentNode" 获得父节点,用 "childNodes"　获得所有的子节点。
parentElement 获取对象层次中的父对象。
parentNode 获取文档层次中的父对象。
childNodes 获取作为指定对象直接后代的 HTML 元素和 TextNode 对象的集合。
children 获取作为对象直接后代的 DHTML 对象的集合。

parentNode 和 parentElement 功能一样, childNodes 和 children 功能一样。但是 parentNode 和 childNodes 是符合W3C标准的
可以说比较通用。而另外两个只是IE支持,不是标准, Firefox 就不支持


Json 与 数组的区别  json 的下标 是一个字符串   数组的下标是数字  json 没有length  数组有 length

getAttribute() 兼容问题  如果是获取class 那么高等级的浏览器没有问题 IE7需要用className

http://www.cnblogs.com/2050/archive/2012/07/14/2591594.html
用innerHTML插入html代码中有样式表时需注意的地方
  document.getElementById('div').innerHTML='<style>p{background:#f00}</style><p>我是p标签</p>';
注意到在IE中，代码中的<style>p{background:#f00}</style> 这段样式声明并没有起作用
解决方法：在样式表前必须要有其他的html代码，即使是一个 &nbsp 也行。

判断页面所有图片加载完成
<script>
先得出图片的数量，然后在每一张图片加载完后的事件中把先前得出的图片数量减1，再判断最后的结果是不是0，如果是0则意味着所有图片都加载完了
var imgNum=$('img').length;
$('img').load(function(){
    if(!--imgNum){alert('All images loaded')}
})
</script>

数据类型转换
[]+1+3  //结果为13
[1]+3   //结果为13
null+1+3  //结果为4

转换成数字
+x //使用一个一元的加号运算符，这是最快的方法
x-0 或 x*1 //另一种形式
Number(x)  //使用不带new的数字构造函数进行转换

对象和函数总是被转换成NaN, undefined也会被转换成NaN, 但null会被转换成0
alert(+[]);  //结果为0
alert(+[1]); //结果为1
alert(+[1,2]); //结果为NaN
alert(+new Array(1)); //结果为0
alert(+new Array(1,2)); //结果为NaN



/*
 * client字面意思的理解是,客户端,在我们的视窗中,客户端就是浏览器。
 * clientHeight就是浏览器可视范围的高度,clientWidth同理。
 * 对于client与offest之间的区别是,client仅仅是可视范围,并不包括滚动条的高度。
 * */

removeChild 的一些问题
<ul id="demo">
<li>a</li>
<li>b</li>
<li>c</li>
</ul>
那么这时候只会删除第一行，因为当删除了一个之后，行的位置会向前移动一位。
giftTrs.length也会相应减一。
var ul = document.getElementById('demo');
var liList = ul.getElementsByTagName('li');
for (var i = 0; i < = liList.length; i++) {
ul.removeChild(liList[i]);
}
正确做法：
var ul = document.getElementById('demo');
var liList = ul.getElementsByTagName('li');
var lilength = liList.length;
for (var i = 0; i < lilength; i++) {
ul.removeChild(liList[0]);
}
IE 下 removeChild 的问题
http://fins.iteye.com/blog/172263/
<html>
 <head>
<script type="text/javascript">

function $(id) {
    return typeof(id)=='string'?document.getElementById(id):id;
}

function removeElement(el){
        el=$(el);
        if (el && el.parentNode) {
            el.parentNode.removeChild(el);
        }
}

  </script>
 </head>

 <body >
  <div id="ttt">aaa</div>

  <input type="button" value="b1" onclick="removeElement('ttt')">
 </body>
</html>

removeNode : isIE ? function(){
    var d;
    return function(n){
        if(n && n.tagName != 'BODY'){
            d = d || document.createElement('div');
            d.appendChild(n);
            d.innerHTML = '';
        }
    }
}() : function(n){
    if(n && n.parentNode && n.tagName != 'BODY'){
        n.parentNode.removeChild(n);
    }
}


http://blog.sina.com.cn/s/blog_6f6360250101hjo7.html js兼容问题


注意事项

 1、所有的相对路径地址,不能做为判断条件(img src href )
    例子 : // img/1.jpg 原始路径
       	 // file:///C:/Users/Administrator/Desktop/11-4-JS1/img/1.jpg // 获得路径
    图片的相对路径不能读,但是可以写!

 2、颜色值 : color: red #f00 rgb() rgba()  颜色值也不能拿来做判断

 3、innerHTML 的值也不能拿来做判断,有兼容性问题?

 4、不要修改表单元素的type值,IE6 7 8 不支持,会报错

 5、修改浮动的兼容问题 , 可以通过写样式来回避这个问题.{float:left} .right{float:right;}
    然后再是oDiv.className='left';

    oDiv.style.float = 'right';     // 有兼容问题
   	oDiv.style.styleFloat = 'right';		// IE styleFloat
   	oDiv.style.cssFloat = 'left';			// 非IE cssFloat

 6、this 指向问题
   	function fn(){
   	    this
   	}
    (1) fn();   this->window
    (2) oDiv.onclick=fn;  this->oDiv
    (3) oDiv.onclick=function(){
            this;   thi->oDiv
        }
    (4) oDiv.onclick=function(){
           fn();   fn()里面的this->window
        }
    (5) <div onclick="this"></div>    this->div
    (6) <div onclick="fn();"></div>   fn()里面的this->window
    (7) funtion fn(obj){
            obj->window
        }
        fn(this);
    (8) oDiv.onclick=function(){
            fn(this);
        }
        function fn(obj){
            obj->Odiv
        }
 7、for循环中的i 与自定义属性
    window.onload = function (){
    	var aBtn = document.getElementsByTagName('input');
    	for( var i=0; i<aBtn.length; i++ ){
    		aBtn[i].index = i;			// 自定义属性（索引值）
    		aBtn[i].onclick = function (){
    			// alert( i );			// 这边永远得到的是3
    			alert( this.index );
    		};
    	}
    };


技巧
奇偶数使用  ['','main-i_right'][i%2]

关注的网站
http://codepen.io/
http://web.jobbole.com/82870/  js 单例模式
http://www.nowcoder.com/828779 牛客网 做面试题
http://www.oxcoder.com/index.action / http://www.oxcoder.com/index.htm 猿圈 目前没有开设前端
http://www.cnblogs.com/2050/archive/2012/08/13/2636467.html#2457812 margin负值
http://ued.taobao.org/blog/ 淘宝 UED 官方博客
http://cued.xunlei.com/  迅雷CUED

问题:  mouseenter mouseleave 已经解决

延迟加载    延迟加载，也称惰性加载，惰性载入等。延迟加载意味着在信息被使用前不会做任何操作：
function addHandler(target, eventType, handler) {
  if (target.addEventListener) {  // DOM2 Events
    addHandler = function(target, eventType, handler) {
      target.addEventListener(eventType, handler, false);
    };
  } else {  // IE
    addHandler = function(target, eventType, handler) {
      target.attachEvent('on' + eventType, handler);
    };
  }
  addHandler(target, eventType, handler);
}

// 调用
addHandler(document, 'click', function() {
  console.log('hello world');
});

addHandler(window, 'keydown', function() {
  console.log('key down');
});
方法在第一次被调用时，会先检查并决定使用哪种方法去绑定事件处理器，然后原始函数被包含正确操作的新函数覆盖。
最后一步调用新的函数（也可以直接return 新的函数），并传入原始参数。
之后的每次调用addHandler()都不会再做检测，因为检测代码已经被新的函数覆盖。

调用延迟加载函数时，第一次总会消耗较长的时间，因为它必须运行检测接着再调用另一个函数完成任务，
但随后调用函数会变快，因为不需要再进行检测。当一个函数在页面中不会立即调用时，延迟加载是最好的选择。

条件预加载 条件预加载会在脚本加载期间提前检测，而不会等到函数被调用：
var addHandler = document.addEventListener ?
  function(target, eventType, handler) {
    target.addEventListener(eventType, handler, false);
  }:
  function(target, eventType, handler) {
    target.attachEvent('on' + eventType, handler);
  };

// 调用
addHandler(document, 'click', function() {
  console.log('hello world');
});

addHandler(window, 'keydown', function() {
  console.log('key down');
});
条件预加载确保所有函数消耗的时间相同，其代价是需要在脚本加载时就检测，而不是加载后。
预加载适用于一个函数马上就要被用到，并且在整个页面的生命周期中频繁出现的场合

webstrom 搜索encoding 设置创建的文件格式为utf-8
webstrom css->other->keep single-line blocks css保持显示一行
         css->appearance->show css color

Bootstrap http://colly.com/   http://foodsense.is/

http://cssreset.com/   normalize.css

把整站做的js效果提炼出来

js中 窗口尺寸还需整理一下

js中 数组不相等

js性能整理

a 标签伪类顺序



js 浏览器兼容性？？
Bootstrap???

cmd 和 amd 的区别？？？
nodejs 看下
准备下自我介绍

请描述你经历过的JavaScript单元测试？？？  Quint jQuery的单位测试框架

数组排序
http://wteamxq.com/testDemo/array.html

position 有多少个属性
标签语义化
absolute 父级没有 relative 怎么办

css3 用的最多的  Transition  圆角 图片撑满的那个属性 background-size:contain;
box-sizing:border-box;  怪异核模型
设置元素居中
nth-of-type()

on方法 中判断是哪个对象 ev 中的

argument 有什么其他属性方法

js 循环输出最终结果的原理  js是单线程

setTimeout() 原理

// 不要一边创建元素，一边给元素添加属性或事件处理函数
var aBtn = document.getElementsByTagName('input');
for (var i=0; i<3; i++) {
	// 只有第三个函数有事件 innerHTML 会先清空页面上所有的按钮在创建
	document.body.innerHTML = document.body.innerHTML + '<input type="button" value="按钮" />';
	// 第一个按钮 = 没有事件处理函数了  0
	// 第二个按钮 = 没有事件处理函数了	 1
	// 第三个按钮 = 有事件处理函数了	 1
	aBtn[i].onclick = function () {
		alert(123);
	};
}

inline-block 加在块元素上是没有效果的

// 第一次for循环为 第一个按钮绑定了事件处理函数，但是函数没有执行，函数执行就只有点击的时候才会执行
// 后面几次循环都是一样，那么你点击完以后 i 就已经是 3了
for(var i=0;i<aBtn.length;i++){

    aBtn[i].onclick=function(){
        alert(i);  // 3
    }

}

camtasia studio
手机端H5上传图片
能调摄像头 本地相册

https://github.com/think2011/localResizeIMG4


http://my.oschina.net/sevenhdu/blog/332014
http://www.cnblogs.com/yexiaochai/p/3567597.html
DOM2级事件规定事件包括三个阶段：

1、 事件捕获阶段

2、处于目标阶段

3、事件冒泡阶段

很多人我都会问他，上个项目用到什么技术，为什么用这个，有什么优缺点，有什么替代方案
对MVC有什么了解，MVVM呢，有没有自己搭过项目架构

熟悉TCP/IP、HTTP基本工作原理？？
HTTP协议
TCP三次握手
web性能瓶颈
代码打包都没试过，sass、less、grunt

了解前端 MVC 开发模式

ecma 5  http://www.open-open.com/lib/view/open1331175932452.html

http://web.jobbole.com/82251/ js 面试题目

http://blog.jobbole.com/29269/

http://www.cnblogs.com/muyou/archive/2012/06/26/2563930.html

JavaScript权威指南

5、JavaScript中如何对一个对象进行深度clone?

10、html 语义话

19、兼容写法 (能力检测)

20、 css计数器

21、 js 中 in 操作符

26、 jquery 动画 animate(params, options) slideUp()

http://www.cnblogs.com/dolphinX/p/3524977.html

37 http://www.cnblogs.com/dolphinX/p/3529249.html 有待研究

http://www.zhangxinxu.com/wordpress/2013/05/%E7%90%86%E8%A7%A3another-javascript-quiz-%E9%A2%98%E7%9B%AE/

http://segmentfault.com/a/1190000002627927 / http://www.cnblogs.com/coco1s/p/4029708.html 必须看 js篇

http://www.jb51.net/article/56847.htm 必须看 css篇


http://alloyteam.github.io/AlloyStick/ 蛮有意思的网站























5.  UML 是什么？在软件开发中怎么使用？
	* 有哪几种关系？    泛化（Generalization）,实现（Realization），关联（Association)，聚合（Aggregation）
	，组合(Composition)，依赖(Dependency)
	* 用例图，包含的元素。参与者，用例，子系统，关系



73、HTML全局属性(global attribute)有哪些

- class:为元素设置类标识，多个类名用空格分开，CSS和javascript可通过class属性获取元素
- `accesskey`:设置快捷键，提供快速访问元素如<a href="#" accesskey="a">aaa</a>在windows下的firefox中按``alt + shift + a``可激活元素

- `contenteditable`: 指定元素内容是否可编辑
- `contextmenu`: 自定义鼠标右键弹出菜单内容
- `data-*`: 为元素增加自定义属性
- `dir`: 设置元素文本方向
- `draggable`: 设置元素是否可拖拽
- `dropzone`: 设置元素拖放类型： copy, move, link
- `hidden`: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果
- `id`: 元素id，文档内唯一
- `lang`: 元素内容的的语言
- `spellcheck`: 是否启动拼写和语法检查
- `style`: 行内css样式
- `tabindex`: 设置元素可以获得焦点，通过tab可以导航
- `title`: 元素相关的建议信息
- `translate`: 元素和子孙节点内容是否需要本地化




### HTTP method

1. 一台服务器要与HTTP1.1兼容，只要为资源实现**GET**和**HEAD**方法即可
2. **GET**是最常用的方法，通常用于**请求服务器发送某个资源**。
3. **HEAD**与GET类似，但**服务器在响应中值返回首部，不返回实体的主体部分**
4. **PUT**让服务器**用请求的主体部分来创建一个由所请求的URL命名的新文档，或者，如果那个URL已经存在的话，就用干这个主体替代它**
5. **POST**起初是用来向服务器输入数据的。实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到要去的地方。
6. **TRACE**会在目的服务器端发起一个环回诊断，最后一站的服务器会弹回一个TRACE响应并在响应主体中携带它收到的原始请求报文。TRACE方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链。
7. **OPTIONS**方法请求web服务器告知其支持的各种功能。可以查询服务器支持哪些方法或者对某些特殊资源支持哪些方法。
8. **DELETE**请求服务器删除请求URL指定的资源


### HTTP request报文结构是怎样的
[rfc2616](http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html)中进行了定义：

1. 首行是**Request-Line**包括：**请求方法**，**请求URI**，**协议版本**，**CRLF**
2. 首行之后是若干行**请求头**，包括**general-header**，**request-header**或者**entity-header**，每个一行以CRLF结束
3. 请求头和消息实体之间有一个**CRLF分隔**
4. 根据实际请求需要可能包含一个**消息实体**
一个请求报文例子如下：

```
GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1
Host: www.w3.org
Connection: keep-alive
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36
Referer: https://www.google.com.hk/
Accept-Encoding: gzip,deflate,sdch
Accept-Language: zh-CN,zh;q=0.8,en;q=0.6
Cookie: authorstyle=yes
If-None-Match: "2cc8-3e3073913b100"
If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT

name=qiu&age=25
```


### HTTP状态码及其含义

参考[RFC 2616](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)

- 1XX：信息状态码
    - **100 Continue**：客户端应当继续发送请求。这个临时相应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求万仇向客户端发送一个最终响应
    - **101 Switching Protocols**：服务器已经理解力客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到Upgrade消息头中定义的那些协议。
- 2XX：成功状态码
    - **200 OK**：请求成功，请求所希望的响应头或数据体将随此响应返回
    - **201 Created**：
    - **202 Accepted**：
    - **203 Non-Authoritative Information**：
    - **204 No Content**：
    - **205 Reset Content**：
    - **206 Partial Content**：
- 3XX：重定向
    - **300 Multiple Choices**：
    - **301 Moved Permanently**：
    - **302 Found**：
    - **303 See Other**：
    - **304 Not Modified**：
    - **305 Use Proxy**：
    - **306 （unused）**：
    - **307 Temporary Redirect**：
- 4XX：客户端错误
    - **400 Bad Request**:
    - **401 Unauthorized**:
    - **402 Payment Required**:
    - **403 Forbidden**:
    - **404 Not Found**:
    - **405 Method Not Allowed**:
    - **406 Not Acceptable**:
    - **407 Proxy Authentication Required**:
    - **408 Request Timeout**:
    - **409 Conflict**:
    - **410 Gone**:
    - **411 Length Required**:
    - **412 Precondition Failed**:
    - **413 Request Entity Too Large**:
    - **414 Request-URI Too Long**:
    - **415 Unsupported Media Type**:
    - **416 Requested Range Not Satisfiable**:
    - **417 Expectation Failed**:
- 5XX: 服务器错误
    - **500 Internal Server Error**:
    - **501 Not Implemented**:
    - **502 Bad Gateway**:
    - **503 Service Unavailable**:
    - **504 Gateway Timeout**:
    - **505 HTTP Version Not Supported**:



### css hack原理及常用hack

原理：利用**不同浏览器对CSS的支持和解析结果不一样**编写针对特定浏览器样式。常见的hack有1）属性hack。2）选择器hack。3）IE条件注释

- IE条件注释：适用于[IE5, IE9]常见格式如下

```
<!--[if IE 6]>
Special instructions for IE 6 here
<![endif]-->
```

- 选择器hack：不同浏览器对选择器的支持不一样

```
/***** Selector Hacks ******/

/* IE6 and below */
* html #uno  { color: red }

/* IE7 */
*:first-child+html #dos { color: red }

/* IE7, FF, Saf, Opera  */
html>body #tres { color: red }

/* IE8, FF, Saf, Opera (Everything but IE 6,7) */
html>/**/body #cuatro { color: red }

/* Opera 9.27 and below, safari 2 */
html:first-child #cinco { color: red }

/* Safari 2-3 */
html[xmlns*=""] body:last-child #seis { color: red }

/* safari 3+, chrome 1+, opera9+, ff 3.5+ */
body:nth-of-type(1) #siete { color: red }

/* safari 3+, chrome 1+, opera9+, ff 3.5+ */
body:first-of-type #ocho {  color: red }

/* saf3+, chrome1+ */
@media screen and (-webkit-min-device-pixel-ratio:0) {
 #diez  { color: red  }
}

/* iPhone / mobile webkit */
@media screen and (max-device-width: 480px) {
 #veintiseis { color: red  }
}

/* Safari 2 - 3.1 */
html[xmlns*=""]:root #trece  { color: red  }

/* Safari 2 - 3.1, Opera 9.25 */
*|html[xmlns*=""] #catorce { color: red  }

/* Everything but IE6-8 */
:root *> #quince { color: red  }

/* IE7 */
*+html #dieciocho {  color: red }

/* Firefox only. 1+ */
#veinticuatro,  x:-moz-any-link  { color: red }

/* Firefox 3.0+ */
#veinticinco,  x:-moz-any-link, x:default  { color: red  }
```

- 属性hack：不同浏览器解析bug或方法

```
/* IE6 */
#once { _color: blue }

/* IE6, IE7 */
#doce { *color: blue; /* or #color: blue */ }

/* Everything but IE6 */
#diecisiete { color/**/: blue }

/* IE6, IE7, IE8 */
#diecinueve { color: blue\9; }

/* IE7, IE8 */
#veinte { color/*\**/: blue\9; }

/* IE6, IE7 -- acts as an !important */
#veintesiete { color: blue !ie; } /* string after ! can be anything */
```
