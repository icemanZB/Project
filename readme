jquery prop 方法解析 http://blog.csdn.net/chaiyining007/article/details/8218038

事件绑定好处  可以绑定多个事件且不会覆盖

dom.onclick=function(){ console.log(1); };
dom.onclick=function(){ console.log(2); };  最终结果是 输出2

scrollTop是什么及用法说明 http://blog.csdn.net/gang_gang_gang/article/details/4233044

scrollTop指的是"元素中的内容"超出"元素上边界"的那部分的高度,向上滚动的数值 scrollTop 如果li中没有内容 scrollTop数值不变

jQuery中跳出 each 循环  continue 可以使用 return true
                        break    可以使用 return false

var _href = _menu.getAttribute('href');  // 获取到 #item1
var _href=_menu.href; // 获取到的是浏览器的路径
<a href="#item1" class="current">1F 男装</a>

使用正则表达式来判断一个字符串中是否有某个字符串
if (/active/.test(aLi[i].className)) {}

javascript中top、clientTop、scrollTop、offsetTop的讲解
http://www.cnblogs.com/trlanfeng/archive/2012/11/04/2753280.html

offsetHeight:为计算后盒子的整体高度 style.top:为绝对定位后的 top 值

offsetTop: 盒子顶部相对定位父级顶部的高度 如果父级没有定位,那就相对于整个页面
offsetTop 只能获取到有定位的父级

offsetTop 和 style.top 的区别
1、offsetTop 返回的是数字,而 style.top 返回的是字符串,除了数字外还带有单位: px
2、offsetTop 只读 而 style.top 可读写
3、如果没有给 HTML 元素指定过 top 样式,则 style.top 返回的是空字符串。

jQuery中的.height()、.innerHeight()和.outerHeight()
.height() 是没有计算过的  不包括padding,不包括边框
获取计算后的整个高度  aLi.outerHeight() = offsetHeight
.innerHeight()  包括padding但不包括border  document.getElementById("div1").clientHeight
.outerHeight()  包括padding和border  还可以接受一个参数,该参数代表是否计算外边距,如果为true则表示计算外边距
js 写法 div1.offsetHeight + parseInt(div1.style.marginTop) + parseInt(div1.style.marginBottom);
js中 offsetHeight 是动态获取值
http://www.kuqin.com/shuoit/20140113/337572.html

jQuery之位置
http://www.cnblogs.com/kissdodog/archive/2012/12/09/2809770.html
oUl.position().top ==> oUl.get(0).offsetTop

$("#content").find(".item") == $('#content .item')  但是后者效率低

var arr=[1,2,3];
pop() 方法用于删除并返回数组的最后一个元素
unshift() 方法可向数组的开头添加一个或更多元素,并返回新的长度

arr.unshift(arr.pop());  // 3   arr => [3, 1, 2]

var arr=[1,2,3];
shift() 方法用于把数组的第一个元素从其中删除,并返回第一个元素的值
push()  方法可向数组的末尾添加一个或多个元素,并返回新的长度

arr.push(arr.shift()); // 3   arr => [2, 3, 1]

Math.random()  random() 方法可返回介于 0 ~ 1 之间的一个随机数

js 中 appendChild 带有剪切功能,并不是复制(可向节点的子节点列表的末尾添加新的子节点)

appendChild 方法是在父级节点中的子节点的末尾添加新的节点(相对于父级节点 来说)
于jquery中的 appendTo() 是一样的

jquery insertBefore() 方法：可在已有的子节点前插入一个新的子节点 (拥有剪切功能)
        insertAfter() 插入到后面 于 insertBefore() 相反

appendChild于insertBefore http://www.cnblogs.com/ATree/archive/2011/09/26/JS-appendChild-insertBefore.html

复制节点 cloneNode() 如果参数是 true 就是一起复制里面的子节点, false 就只复制当前节点 不会复制里面的子节点
返回的节点不属于文档树,它的 parentNode 属性为 null
当复制的是 Element 节点时,它的所有属性都将被复制,但要注意,当前节点上注册的事件监听器函数不会被复制

jquery clone() 无参数的情况是潜复制(不复制事件)  clone(true) 深复制(复制事件)

jquery stop() 方法停止当前正在运行的动画
工作中遇到过的实际案例:
在项目里做的一个下拉菜单,当鼠标移上去的时候就菜单显示,当鼠标离开的时候菜单隐藏

如果我快速不断地将鼠标移入移出菜单(即当菜单下拉动画未完成时,鼠标又移出了菜单)就会产生"动画积累"
当鼠标停止移动后,积累的动画还会持续执行,直到动画序列执行完毕

解决方法:在写动画效果的代码前加入 stop(true,true) 这样每次快速的移入移出菜单就正常了
当移入一个菜单的时候,停止所有加入队列的动画,但是完成当前的动画(跳至当前动画的最终效果位置)

Math.pow(x,y) x 的 y 次幂

$(window).width()  获取窗口的宽度

容器页面居中 ($(window).width()-$('#obj').outWidth())/2 、 ($(window).height()-$('#obj').outHeight())/2

触发滚动条事件和resize

$(window).on('resize scroll',function(){
    $('div').css('top',($(window).height()-$('#obj').outHeight())/2 + $(window).scroll());
})

js里用 "parentNode" 获得父节点,用 "childNodes"　获得所有的子节点。
parentElement 获取对象层次中的父对象。
parentNode 获取文档层次中的父对象。
childNodes 获取作为指定对象直接后代的 HTML 元素和 TextNode 对象的集合。
children 获取作为对象直接后代的 DHTML 对象的集合。

parentNode 和 parentElement 功能一样, childNodes 和 children 功能一样。但是 parentNode 和 childNodes 是符合W3C标准的
可以说比较通用。而另外两个只是IE支持,不是标准, Firefox 就不支持


Json 与 数组的区别  json 的下标 是一个字符串   数组的下标是数字  json 没有length  数组有 length

getAttribute() 兼容问题  如果是获取class 那么高等级的浏览器没有问题 IE7需要用className


/*
 * client字面意思的理解是,客户端,在我们的视窗中,客户端就是浏览器。
 * clientHeight就是浏览器可视范围的高度,clientWidth同理。
 * 对于client与offest之间的区别是,client仅仅是可视范围,并不包括滚动条的高度。
 * */

removeChild 的一些问题
<ul id="demo">
<li>a</li>
<li>b</li>
<li>c</li>
</ul>
那么这时候只会删除第一行，因为当删除了一个之后，行的位置会向前移动一位。
giftTrs.length也会相应减一。
var ul = document.getElementById('demo');
var liList = ul.getElementsByTagName('li');
for (var i = 0; i < = liList.length; i++) {
ul.removeChild(liList[i]);
}
正确做法：
var ul = document.getElementById('demo');
var liList = ul.getElementsByTagName('li');
var lilength = liList.length;
for (var i = 0; i < lilength; i++) {
ul.removeChild(liList[0]);
}
IE 下 removeChild 的问题
http://fins.iteye.com/blog/172263/
<html>
 <head>
<script type="text/javascript">

function $(id) {
    return typeof(id)=='string'?document.getElementById(id):id;
}

function removeElement(el){
        el=$(el);
        if (el && el.parentNode) {
            el.parentNode.removeChild(el);
        }
}

  </script>
 </head>

 <body >
  <div id="ttt">aaa</div>

  <input type="button" value="b1" onclick="removeElement('ttt')">
 </body>
</html>

removeNode : isIE ? function(){
    var d;
    return function(n){
        if(n && n.tagName != 'BODY'){
            d = d || document.createElement('div');
            d.appendChild(n);
            d.innerHTML = '';
        }
    }
}() : function(n){
    if(n && n.parentNode && n.tagName != 'BODY'){
        n.parentNode.removeChild(n);
    }
}


http://blog.sina.com.cn/s/blog_6f6360250101hjo7.html js兼容问题


注意事项

 1、所有的相对路径地址,不能做为判断条件(img src href )
    例子 : // img/1.jpg 原始路径
       	 // file:///C:/Users/Administrator/Desktop/11-4-JS1/img/1.jpg // 获得路径
    图片的相对路径不能读,但是可以写!

 2、颜色值 : color: red #f00 rgb() rgba()  颜色值也不能拿来做判断

 3、innerHTML 的值也不能拿来做判断,有兼容性问题?

 4、不要修改表单元素的type值,IE6 7 8 不支持,会报错

 5、修改浮动的兼容问题 , 可以通过写样式来回避这个问题.{float:left} .right{float:right;}
    然后再是oDiv.className='left';

    oDiv.style.float = 'right';     // 有兼容问题
   	oDiv.style.styleFloat = 'right';		// IE styleFloat
   	oDiv.style.cssFloat = 'left';			// 非IE cssFloat

 6、this 指向问题
   	function fn(){
   	    this
   	}
    (1) fn();   this->window
    (2) oDiv.onclick=fn;  this->oDiv
    (3) oDiv.onclick=function(){
            this;   thi->oDiv
        }
    (4) oDiv.onclick=function(){
           fn();   fn()里面的this->window
        }
    (5) <div onclick="this"></div>    this->div
    (6) <div onclick="fn();"></div>   fn()里面的this->window
    (7) funtion fn(obj){
            obj->window
        }
        fn(this);
    (8) oDiv.onclick=function(){
            fn(this);
        }
        function fn(obj){
            obj->Odiv
        }
 7、for循环中的i 与自定义属性
    window.onload = function (){
    	var aBtn = document.getElementsByTagName('input');
    	for( var i=0; i<aBtn.length; i++ ){
    		aBtn[i].index = i;			// 自定义属性（索引值）
    		aBtn[i].onclick = function (){
    			// alert( i );			// 这边永远得到的是3
    			alert( this.index );
    		};
    	}
    };



关注的网站
http://codepen.io/
http://web.jobbole.com/82870/  js 单例模式
http://www.nowcoder.com/828779 牛客网 做面试题
http://www.oxcoder.com/index.action / http://www.oxcoder.com/index.htm 猿圈 目前没有开设前端

问题:  mouseenter mouseleave 已经解决
