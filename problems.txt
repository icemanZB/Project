Mootools ？？
css 预编译 模块化
js 模板引擎
js断流
高阶函数  http://www.cnblogs.com/dojo-lzz/p/4576083.html
         http://dengo.org/archives/1004
jquery源码
promise的问题    http://www.ruanyifeng.com/blog/2011/08/a_detailed_explanation_of_jquery_deferred_object.html
 http://www.zhangxinxu.com/wordpress/2014/02/es6-javascript-promise-%E6%84%9F%E6%80%A7%E8%AE%A4%E7%9F%A5/

jQuery性能： http://www.ruanyifeng.com/blog/2011/08/jquery_best_practices.html

http://web.jobbole.com/82251/ js 面试题目

http://blog.jobbole.com/29269/

http://www.cnblogs.com/muyou/archive/2012/06/26/2563930.html

HTML全局属性(global attribute)有哪些
参考资料：[MDN: html global attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes)或者[W3C HTML global-attributes](http://www.w3.org/TR/html-markup/global-attributes.html#common.attrs.core)

](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction)**:

### 如何进行网站性能优化

[雅虎Best Practices for Speeding Up Your Web Site](https://developer.yahoo.com/performance/rules.html)：

SGML？？？？

JavaScript权威指南

5、JavaScript中如何对一个对象进行深度clone?

19、兼容写法 (能力检测)

20、 css计数器

21、 js 中 in 操作符

26、 jquery 动画 animate(params, options) slideUp()

http://www.cnblogs.com/dolphinX/p/3524977.html

37 http://www.cnblogs.com/dolphinX/p/3529249.html 有待研究

http://www.zhangxinxu.com/wordpress/2013/05/%E7%90%86%E8%A7%A3another-javascript-quiz-%E9%A2%98%E7%9B%AE/


js 浏览器兼容性？？
Bootstrap???

cmd 和 amd 的区别？？？
nodejs 看下
准备下自我介绍

请描述你经历过的JavaScript单元测试？？？  Quint jQuery的单位测试框架

数组排序
http://wteamxq.com/testDemo/array.html

position 有多少个属性
标签语义化
absolute 父级没有 relative 怎么办

css3 用的最多的  Transition  圆角 图片撑满的那个属性 background-size:contain;
box-sizing:border-box;  怪异核模型
设置元素居中
nth-of-type()

on方法 中判断是哪个对象 ev 中的

argument 有什么其他属性方法

js 循环输出最终结果的原理  js是单线程

setTimeout() 原理

// 不要一边创建元素，一边给元素添加属性或事件处理函数
var aBtn = document.getElementsByTagName('input');
for (var i=0; i<3; i++) {
	// 只有第三个函数有事件 innerHTML 会先清空页面上所有的按钮在创建
	document.body.innerHTML = document.body.innerHTML + '<input type="button" value="按钮" />';
	// 第一个按钮 = 没有事件处理函数了  0
	// 第二个按钮 = 没有事件处理函数了	 1
	// 第三个按钮 = 有事件处理函数了	 1
	aBtn[i].onclick = function () {
		alert(123);
	};
}

inline-block 加在块元素上是没有效果的

// 第一次for循环为 第一个按钮绑定了事件处理函数，但是函数没有执行，函数执行就只有点击的时候才会执行
// 后面几次循环都是一样，那么你点击完以后 i 就已经是 3了
for(var i=0;i<aBtn.length;i++){

    aBtn[i].onclick=function(){
        alert(i);  // 3
    }

}

camtasia studio
手机端H5上传图片
能调摄像头 本地相册

https://github.com/think2011/localResizeIMG4


http://my.oschina.net/sevenhdu/blog/332014
http://www.cnblogs.com/yexiaochai/p/3567597.html
DOM2级事件规定事件包括三个阶段：

1、 事件捕获阶段

2、处于目标阶段

3、事件冒泡阶段

很多人我都会问他，上个项目用到什么技术，为什么用这个，有什么优缺点，有什么替代方案
对MVC有什么了解，MVVM呢，有没有自己搭过项目架构

熟悉TCP/IP、HTTP基本工作原理？？
HTTP协议
TCP三次握手
web性能瓶颈
代码打包都没试过，sass、less、grunt

了解前端 MVC 开发模式

ecma 5  http://www.open-open.com/lib/view/open1331175932452.html


http://www.jb51.net/article/43261.htm 浮动
http://blog.csdn.net/return_false/article/details/11203025 清除浮动

border 研究三角??


http://www.cnblogs.com/webblog/archive/2009/07/07/1518274.html  css选择器

http://www.cnblogs.com/2050/archive/2012/08/13/2636467.html#2457812 margin负值


压缩要学习下

bind() 研究下

http://www.phperz.com/article/14/0925/25668.html  不错面试题目

http://blog.csdn.net/dyllove98/article/details/8981433 好文章 有深度的 css

http://www.ruanyifeng.com  不错

http://blog.jobbole.com/54495/  不错js技巧


JQuery的源码看过吗？能不能简单说一下它的实现原理？


写一个通用的事件侦听器函数。

    // event(事件)工具集，来源：github.com/markyun
    markyun.Event = {
        // 页面加载完成后
        readyEvent : function(fn) {
            if (fn==null) {
                fn=document;
            }
            var oldonload = window.onload;
            if (typeof window.onload != 'function') {
                window.onload = fn;
            } else {
                window.onload = function() {
                    oldonload();
                    fn();
                };
            }
        },
        // 视能力分别使用dom0||dom2||IE方式 来绑定事件
        // 参数： 操作的元素,事件名称 ,事件处理程序
        addEvent : function(element, type, handler) {
            if (element.addEventListener) {
                //事件类型、需要执行的函数、是否捕捉
                element.addEventListener(type, handler, false);
            } else if (element.attachEvent) {
                element.attachEvent('on' + type, function() {
                    handler.call(element);
                });
            } else {
                element['on' + type] = handler;
            }
        },
        // 移除事件
        removeEvent : function(element, type, handler) {
            if (element.removeEnentListener) {
                element.removeEnentListener(type, handler, false);
            } else if (element.datachEvent) {
                element.detachEvent('on' + type, handler);
            } else {
                element['on' + type] = null;
            }
        },
        // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)
        stopPropagation : function(ev) {
            if (ev.stopPropagation) {
                ev.stopPropagation();
            } else {
                ev.cancelBubble = true;
            }
        },
        // 取消事件的默认行为
        preventDefault : function(event) {
            if (event.preventDefault) {
                event.preventDefault();
            } else {
                event.returnValue = false;
            }
        },
        // 获取事件目标
        getTarget : function(event) {
            return event.target || event.srcElement;
        },
        // 获取event对象的引用，取到事件的所有信息，确保随时能使用event；
        getEvent : function(e) {
            var ev = e || window.event;
            if (!ev) {
                var c = this.getEvent.caller;
                while (c) {
                    ev = c.arguments[0];
                    if (ev && Event == ev.constructor) {
                        break;
                    }
                    c = c.caller;
                }
            }
            return ev;
        }
    };

对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？

     前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。
    1、实现界面交互
    2、提升用户体验
    3、有了Node.js，前端可以实现服务端的一些事情

前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好，

 参与项目，快速高质量完成实现效果图，精确到1px；

 与团队成员，UI设计，产品经理的沟通；

 做好的页面结构，页面重构和用户体验；

 处理hack，兼容、写出优美的代码格式；

 针对服务器的优化、拥抱最新前端技术。

加班的看法？

加班就像借钱，原则应当是------救急不救穷


平时如何管理你的项目？

先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等；

编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；

标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；

页面进行标注（例如 页面 模块 开始和结束）；

CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）；

JS 分文件夹存放 命名以该JS功能为准的英文翻译。

图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理


KISSY.？？？？



### 评价一下三种方法实现继承的优缺点,并改进

```
function Shape() {}

function Rect() {}

// 方法1
Rect.prototype = new Shape();

// 方法2
Rect.prototype = Shape.prototype;

// 方法3
Rect.prototype = Object.create(Shape.prototype);

Rect.prototype.area = function () {
  // do something
};
```

方法1：

1. 优点：正确设置原型链实现继承
2. 优点：父类实例属性得到继承，原型链查找效率提高，也能为一些属性提供合理的默认值
3. 缺点：父类实例属性为引用类型时，不恰当地修改会导致所有子类被修改
4. 缺点：创建父类实例作为子类原型时，可能无法确定构造函数需要的合理参数，这样提供的参数继承给子类没有实际意义，当子类需要这些参数时应该在构造函数中进行初始化和设置
5. 总结：继承应该是继承方法而不是属性，为子类设置父类实例属性应该是通过在子类构造函数中调用父类构造函数进行初始化

方法2：

1. 优点：正确设置原型链实现继承
2. 缺点：父类构造函数原型与子类相同。修改子类原型添加方法会修改父类

方法3：

1. 优点：正确设置原型链且避免方法1.2中的缺点
2. 缺点：ES5方法需要注意兼容性

改进：

1. 所有三种方法应该在子类构造函数中调用父类构造函数实现实例属性初始化

```
function Rect() {
    Shape.call(this);
}
```


2. 用新创建的对象替代子类默认原型，设置``Rect.prototype.constructor = Rect;``保证一致性
3. 第三种方法的polyfill：

```
function create(obj) {
    if (Object.create) {
        return Object.create(obj);
    }

    function f() {};
    f.prototype = obj;
    return new f();
}
```



### 现有一个Page类,其原型对象上有许多以post开头的方法(如postMsg);另有一拦截函数chekc,只返回ture或false.请设计一个函数,该函数应批量改造原Page的postXXX方法,在保留其原有功能的同时,为每个postXXX方法增加拦截验证功能,当chekc返回true时继续执行原postXXX方法,返回false时不再执行原postXXX方法

```
function Page() {}

Page.prototype = {
  constructor: Page,

  postA: function (a) {
    console.log('a:' + a);
  },
  postB: function (b) {
    console.log('b:' + b);
  },
  postC: function (c) {
    console.log('c:' + c);
  },
  check: function () {
    return Math.random() > 0.5;
  }
}

function checkfy(obj) {
  for (var key in obj) {
    if (key.indexOf('post') === 0 && typeof obj[key] === 'function') {
      (function (key) {
        var fn = obj[key];
        obj[key] = function () {
          if (obj.check()) {
            fn.apply(obj, arguments);
          }
        };
      }(key));
    }
  }
} // end checkfy()

checkfy(Page.prototype);

var obj = new Page();

obj.postA('checkfy');
obj.postB('checkfy');
obj.postC('checkfy');
```


### 网页中实现一个计算当年还剩多少时间的倒数计时程序,要求网页上实时动态显示"××年还剩××天××时××分××秒"

    <!doctype html>
    <html>
    <head>
        <meta charset="utf-8">
        <title>TEst</title>
    </head>
    <body>

        <span id="target"></span>


    <script type="text/javascript">
        // 为了简化。每月默认30天
        function getTimeString() {
            var start = new Date();
            var end = new Date(start.getFullYear() + 1, 0, 1);
            var elapse = Math.floor((end - start) / 1000);

            var seconds = elapse % 60 ;
            var minutes = Math.floor(elapse / 60) % 60;
            var hours = Math.floor(elapse / (60 * 60)) % 24;
            var days = Math.floor(elapse / (60 * 60 * 24)) % 30;
            var months = Math.floor(elapse / (60 * 60 * 24 * 30)) % 12;
            var years = Math.floor(elapse / (60 * 60 * 24 * 30 * 12));

            return start.getFullYear() + '年还剩' + years + '年' + months + '月' + days + '日'
                + hours + '小时' + minutes + '分' + seconds + '秒';
        }

        function domText(elem, text) {
            if (text == undefined) {

                if (elem.textContent) {
                    return elem.textContent;
                } else if (elem.innerText) {
                    return elem.innerText;
                }
            } else {
                if (elem.textContent) {
                    elem.textContent = text;
                } else if (elem.innerText) {
                    elem.innerText = text;
                } else {
                    elem.innerHTML = text;
                }
            }
        }

        var target = document.getElementById('target');

        setInterval(function () {
            domText(target, getTimeString());
        }, 1000)
    </script>

    </body>
    </html>

### 完成一个函数,接受数组作为参数,数组元素为整数或者数组,数组元素包含整数或数组,函数返回扁平化后的数组
如：[1, [2, [ [3, 4], 5], 6]] => [1, 2, 3, 4, 5, 6]

```
    var data =  [1, [2, [ [3, 4], 5], 6]];

    function flat(data, result) {
        var i, d, len;
        for (i = 0, len = data.length; i < len; ++i) {
            d = data[i];
            if (typeof d === 'number') {
                result.push(d);
            } else {
                flat(d, result);
            }
        }
    }

    var result = [];
    flat(data, result);

    console.log(result);
```


### 请评价以下事件监听器代码并给出改进意见

```
if (window.addEventListener) {
  var addListener = function (el, type, listener, useCapture) {
    el.addEventListener(type, listener, useCapture);
  };
}
else if (document.all) {
  addListener = function (el, type, listener) {
    el.attachEvent('on' + type, function () {
      listener.apply(el);
    });
  };
}
```

作用：浏览器功能检测实现跨浏览器DOM事件绑定

优点：

1. 测试代码只运行一次，根据浏览器确定绑定方法
2. 通过``listener.apply(el)``解决IE下监听器this与标准不一致的地方
3. 在浏览器不支持的情况下提供简单的功能，在标准浏览器中提供捕获功能

缺点：

1. document.all作为IE检测不可靠，应该使用if(el.attachEvent)
2. addListener在不同浏览器下API不一样
3. ``listener.apply``使this与标准一致但监听器无法移除
4. 未解决IE下listener参数event。 target问题

改进:

```
var addListener;

if (window.addEventListener) {
  addListener = function (el, type, listener, useCapture) {
    el.addEventListener(type, listener, useCapture);
    return listener;
  };
}
else if (window.attachEvent) {
  addListener = function (el, type, listener) {
    // 标准化this，event，target
    var wrapper = function () {
      var event = window.event;
      event.target = event.srcElement;
      listener.call(el, event);
    };

    el.attachEvent('on' + type, wrapper);
    return wrapper;
    // 返回wrapper。调用者可以保存，以后remove
  };
}
```



### 解析一个完整的url,返回Object包含域与window.location相同

```
/**
 * 解析一个url并生成window.location对象中包含的域
 * location:
 * {
 *      href: '包含完整的url',
 *      origin: '包含协议到pathname之前的内容',
 *      protocol: 'url使用的协议，包含末尾的:',
 *      username: '用户名', // 暂时不支持
 *      password: '密码',  // 暂时不支持
 *      host: '完整主机名，包含:和端口',
 *      hostname: '主机名，不包含端口'
 *      port: '端口号',
 *      pathname: '服务器上访问资源的路径/开头',
 *      search: 'query string，?开头',
 *      hash: '#开头的fragment identifier'
 * }
 *
 * @param {string} url 需要解析的url
 * @return {Object} 包含url信息的对象
 */
function parseUrl(url) {
    var result = {};
    var keys = ['href', 'origin', 'protocol', 'host',
                'hostname', 'port', 'pathname', 'search', 'hash'];
    var i, len;
    var regexp = /(([^:]+:)\/\/(([^:\/\?#]+)(:\d+)?))(\/[^?#]*)?(\?[^#]*)?(#.*)?/;

    var match = regexp.exec(url);

    if (match) {
        for (i = keys.length - 1; i >= 0; --i) {
            result[keys[i]] = match[i] ? match[i] : '';
        }
    }

    return result;
}
```

### 完成函数getViewportSize返回指定窗口的视口尺寸

```
/**
* 查询指定窗口的视口尺寸，如果不指定窗口，查询当前窗口尺寸
**/
function getViewportSize(w) {
    w = w || window;

    // IE9及标准浏览器中可使用此标准方法
    if ('innerHeight' in w) {
        return {
            width: w.innerWidth,
            height: w.innerHeight
        };
    }

    var d = w.document;
    // IE 8及以下浏览器在标准模式下
    if (document.compatMode === 'CSS1Compat') {
        return {
            width: d.documentElement.clientWidth,
            height: d.documentElement.clientHeight
        };
    }

    // IE8及以下浏览器在怪癖模式下
    return {
        width: d.body.clientWidth,
        height: d.body.clientHeight
    };
}
```

### 完成函数getScrollOffset返回窗口滚动条偏移量

    /**
     * 获取指定window中滚动条的偏移量，如未指定则获取当前window
     * 滚动条偏移量
     *
     * @param {window} w 需要获取滚动条偏移量的窗口
     * @return {Object} obj.x为水平滚动条偏移量,obj.y为竖直滚动条偏移量
     */
    function getScrollOffset(w) {
        w =  w || window;
        // 如果是标准浏览器
        if (w.pageXOffset != null) {
            return {
                x: w.pageXOffset,
                y: w.pageYOffset
            };
        }

        // 老版本IE，根据兼容性不同访问不同元素
        var d = w.document;
        if (d.compatMode === 'CSS1Compat') {
            return {
                x: d.documentElement.scrollLeft,
                y: d.documentElement.scrollTop
            }
        }

        return {
            x: d.body.scrollLeft,
            y: d.body.scrollTop
        };
    }


### 现有一个字符串richText,是一段富文本,需要显示在页面上.有个要求,需要给其中只包含一个img元素的p标签增加一个叫pic的class.请编写代码实现.
可以使用jQuery或KISSY.

    function richText(text) {
        var div = document.createElement('div');
        div.innerHTML = text;
        var p = div.getElementsByTagName('p');
        var i, len;

        for (i = 0, len = p.length; i < len; ++i) {
            if (p[i].getElementsByTagName('img').length === 1) {
                p[i].classList.add('pic');
            }
        }

        return div.innerHTML;
    }

### 请实现一个Event类,继承自此类的对象都会拥有两个方法on,off,once和trigger


    function Event() {
        if (!(this instanceof Event)) {
            return new Event();
        }
        this._callbacks = {};
    }
    Event.prototype.on = function (type, handler) {
        this_callbacks = this._callbacks || {};
        this._callbacks[type] = this.callbacks[type] || [];
        this._callbacks[type].push(handler);

        return this;
    };

    Event.prototype.off = function (type, handler) {
        var list = this._callbacks[type];

        if (list) {
            for (var i = list.length; i >= 0; --i) {
                if (list[i] === handler) {
                    list.splice(i, 1);
                }
            }
        }

        return this;
    };

    Event.prototype.trigger = function (type, data) {
        var list = this._callbacks[type];

        if (list) {
            for (var i = 0, len = list.length; i < len; ++i) {
                list[i].call(this, data);
            }
        }
    };

    Event.prototype.once = function (type, handler) {
        var self = this;

        function wrapper() {
            handler.apply(self, arguments);
            self.off(type, wrapper);
        }
        this.on(type, wrapper);
        return this;
    };

```


### 使用原生javascript给下面列表中的li节点绑定点击事件,点击时创建一个Object对象,兼容IE和标准浏览器

```
<ul id="nav">
    <li><a href="http://11111">111</a></li>
    <li><a href="http://2222">222</a></li>
    <li><a href="http://333">333</a></li>
    <li><a href="http://444">444</a></li>
</ul>

Object:
{
    "index": 1,
    "name": "111",
    "link": "http://1111"
}
```

script:

```
var EventUtil = {
    getEvent: function (event) {
        return event || window.event;
    },
    getTarget: function (event) {
        return event.target || event.srcElement;
    },
    // 返回注册成功的监听器，IE中需要使用返回值来移除监听器
    on: function (elem, type, handler) {
        if (elem.addEventListener) {
            elem.addEventListener(type, handler, false);
            return handler;
        } else if (elem.attachEvent) {
            function wrapper(event) {
                return handler.call(elem, event);
            };
            elem.attachEvent('on' + type, wrapper);
            return wrapper;
        }
    },
    off: function (elem, type, handler) {
        if (elem.removeEventListener) {
            elem.removeEventListener(type, handler, false);
        } else if (elem.detachEvent) {
            elem.detachEvent('on' + type, handler);
        }
    },
    preventDefault: function (event) {
        if (event.preventDefault) {
            event.preventDefault();
        } else if ('returnValue' in event) {
            event.returnValue = false;
        }
    },
    stopPropagation: function (event) {
        if (event.stopPropagation) {
            event.stopPropagation();
        } else if ('cancelBubble' in event) {
            event.cancelBubble = true;
        }
    }
};
var DOMUtil = {
    text: function (elem) {
        if ('textContent' in elem) {
            return elem.textContent;
        } else if ('innerText' in elem) {
            return elem.innerText;
        }
    },
    prop: function (elem, propName) {
        return elem.getAttribute(propName);
    }
};

var nav = document.getElementById('nav');

EventUtil.on(nav, 'click', function (event) {
    var event = EventUtil.getEvent(event);
    var target = EventUtil.getTarget(event);

    var children = this.children;
    var i, len;
    var anchor;
    var obj = {};

    for (i = 0, len = children.length; i < len; ++i) {
        if (children[i] === target) {
            obj.index = i + 1;
            anchor = target.getElementsByTagName('a')[0];
            obj.name = DOMUtil.text(anchor);
            obj.link = DOMUtil.prop(anchor, 'href');
        }
    }

    alert('index: ' + obj.index + ' name: ' + obj.name +
        ' link: ' + obj.link);
});
```

### 有一个大数组,var a = ['1', '2', '3', ...];a的长度是100,内容填充随机整数的字符串.请先构造此数组a,然后设计一个算法将其内容去重

```
    /**
    * 数组去重
    **/
    function normalize(arr) {
        if (arr && Array.isArray(arr)) {
            var i, len, map = {};
            for (i = arr.length; i >= 0; --i) {
                if (arr[i] in map) {
                    arr.splice(i, 1);
                } else {
                    map[arr[i]] = true;
                }
            }
        }
        return arr;
    }

    /**
    * 用100个随机整数对应的字符串填充数组。
    **/
    function fillArray(arr, start, end) {
        start = start == undefined ? 1 : start;
        end = end == undefined ?  100 : end;

        if (end <= start) {
            end = start + 100;
        }

        var width = end - start;
        var i;
        for (i = 100; i >= 1; --i) {
            arr.push('' + (Math.floor(Math.random() * width) + start));
        }
        return arr;
    }

    var input = [];
    fillArray(input, 1, 100);
    input.sort(function (a, b) {
        return a - b;
    });
    console.log(input);

    normalize(input);
    console.log(input);
```

26、JavaScript在IE浏览器和Firefox浏览器中的差异总结

    (1) HTML对象的 id 作为对象名的问题

        IE: HTML 对象的 ID 可以作为 document 的下属对象变量名直接使用
        Firefox: 不支持
    解决方法: 使用document.getElementById 替代 document.all

    (2) 如果控件只有name,没有id, 用 getElementById 时:

        IE: 可以找到对象
        Firefox: 返回NULL
    解决方法: 所有控件必须设置ID属性

    (3) Eval:

        IE: 支持,利用 eval(idName) 可以取得 id 为 idName 的 HTML 对象
        Firefox: 不支持
    解决方法: 统一使用 getElementById(idName) 代替 eval(idName)

    (4) Event:

        IE: 用全局对象window.event
        Firefox: event只能在事件发生的现场使用,在调用函数时传入event对象 function(ev){}
    解决方法: 使用之前做一下浏览器类型判断,各用各的。

    (5) 对象名称中美元符号'$' 改为使用下划线'_'

    (6) 集合类对象问题

        IE: 可以使用()或[]获取集合类对象
        Firefox: 只能使用[]获取集合类对象

    解决方法: 统一使用[]获取集合类对象。
        例: document.form.item("itemName") 这样的语句改为 document.form.elements["elementName"]

    (7) 变量名与某 HTML 对象 id 相同的问题

        IE: 不能使用与 HTML 对象 id 相同的变量名
        Firefox: 可以使用
    解决方法: 在声明变量时,一律加上 var 以避免歧义,这样在 IE 中亦可正常运行。
            此外,最好不要取与 HTML 对象 id 相同的变量名,以减少错误。

    (8) Event定位问题

        IE: 支持 event.x 和 event.y
        Firefox: 支持 event.pageX 和 event.pageY
    解决方法: 统一使用 event.clientX 和 event.clientY
            但是在Firefox中 event.clientX 与 event.pageX 有微妙的差别(当整个页面有滚动条的时候)
            不过大多数时候是等效的。如果要完全一样,可以判断浏览器类型后对应使用。

    (9) 父结点的问题

        IE: parentElement parentElement.children
        Firefox: parentNode parentNode.childNodes
        childNodes的下标的含义在IE和Firefox中不同,Firefox使用DOM规范,childNodes中会插入空白文本节点。
        一般可以通过node.getElementsByTagName()来回避这个问题。
        当html中节点缺失时,IE和Firefox对parentNode的解释不同。例如:

    <form>
        <table>
            <input/>
        </table>
    </form>
    IE: input.parentNode的值为空节点
    Firefox: input.parentNode的值为form
    解决方法: Firefox中节点没有removeNode方法,必须使用如下方法 node.parentNode.removeChild(node)

    (10) const 问题

        IE: 不支持 const 关键字。如 const constVar = 32; 在IE中这是语法错误
        Firefox: 支持
    解决方法: 不使用 const 以 var 代替

    (11) body 对象

        IE: 在body标签完全被读入之后才存在
        Firefox: 在body标签没有被浏览器完全读入之前就存在

    (12) 自定义属性问题

        IE: 可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性
        Firefox: 只能使用getAttribute()获取自定义属性
    解决方法: 统一通过getAttribute()获取自定义属性

    (13) event.srcElement问题

        IE: even.srcElement
        Firefox: even.target
    解决方法: 使用时判断浏览器类型,各用各的

    (14) 模态和非模态窗口

        IE: 支持模态和非模态窗口
        Firefox: 不支持
    解决方法: 直接使用window.open(pageURL,name,parameters)方式打开新窗口。
            如果需要将子窗口中的参数传递回父窗口,可以在子窗口中使用window.opener来访问父窗口。

    (15) innerText

        IE: innerText
        Firefox: textContent

    (16) 类似 obj.style.height = imgObj.height 的语句

        IE: 有效
        Firefox: 无效
        解决方法: 统一使用obj.style.height = imgObj.height + 'px';